# 笔试/面试总结

构造函数没有返回值。

---

同步容器和并发容器：

在Java中，同步容器包括两个部分，一个是vector和HashTable，查看vector、HashTable的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchornized。另一个是Collections类中提供的静态工厂方法创建的同步包装类。

同步容器通过对容器的所有状态进行串行访问，从而实现它们的线程安全。这样做的代价是削弱了并发性，当多个线程共同竞争容器级的锁时，吞吐量就会降低。

---

并发容器是为多线程并发访问而设计的。 ConcurrentHashMap与HashMap一样是一个哈希表，但是它使用完全不同的锁策略，可以提供更好的并发性和可伸缩性。 

ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock

一个ConcurrentHashMap里包含一个Segment数组，每个Segment守护着HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment的锁。

concurrentHashMap 不是通过synchronized 来实现并发访问的。这是一个并发容器。

---

1. 读写原始数据，一般采用什么流？（AC ）

A InputStream

B DataInputStream

C OutputStream

D BufferedInputStream

2. 为了提高读写性能，可以采用什么流？（ DF）

A InputStream

B DataInputStream

C BufferedReader

D BufferedInputStream

E OutputStream

F BufferedOutputStream

3. 对各种基本数据类型和String类型的读写，采用什么流？（ AD）

A DataInputStream

B BufferedReader

C PrintWriter

D DataOutputStream

E ObjectInputStream

F ObjectOutputStream

4. 能指定字符编码的I/O流类型是：（BH ）

A Reader

B InputStreamReader

C BufferedReader

D Writer

E PrintWriter

F ObjectInputStream

G ObjectOutputStream

H OutputStreamWriter

6. File类型中定义了什么方法来创建一级目录？（ C）

A createNewFile

B exists

C mkdirs

D mkdir

7. 对文本文件操作用什么I/O流？（AD ）

A FileReader

B FileInputStream

C RandomAccessFile

D FileWriter

---

public static void main(String []args){

    int i;

    System.out.println(i);

}

Error:(9, 28) java: 可能尚未初始化变量i

---

当finalize()抛出异常的时候会被忽略。而且，对象的终结将在此停止，导致对象处在一种不确定的状态。如果另一个进程试图使用这个对象的话，将产生不确定的结果。通常抛出异常将会导致线程终止并产生一个提示信息，但是从finalize()中抛出异常就不会。

---

pop3和SMPT

SMTP管‘发’，POP3/IMAP管‘收’。

SMTP(Simple Mail Transfer Protocol)简易邮件传输通讯协议. SMTP是互联网上的一种通讯协议，主要功能是用在传送电子邮件，当我们通过电子邮件程序，寄E-mil给另外一个人时，必须通过SMTP通讯协议，将邮件送到对方的邮件服务器上

POP（Post Office Protocol）邮局通讯协定POP是互联网上的一种通讯协定，当我们寄信给另外一个人时，对方当时多半不会在线上，所以邮件服务器必须为收信者保存这封信，直到收信者来检查这封信件。当收信人收信的时候，必须通过POP通讯协定，才能取得邮件。

IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，是一个应用层协议（端口是143）。用来从本地邮件客户端（Outlook Express、Foxmail、Mozilla Thunderbird等）访问远程服务器上的邮件。它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。

---

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP面向报文，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

---

DHCP: 封装在UDP

DNS:既用到了tcp也用到了udp，在域名解析的过程中是udp，在区域传输时用的是tcp（辅助域名服务器向主域名服务器定时请求同步数据，）两个原因：1.可靠，2.udp报文最大512字节，盛不下。

路由器是OSI那一层 ----网络层

基数排序：

Tcp/IP 中提供端到端通信的是哪一层？：传输层，网络层：点对点。

---

滴滴：

一面：

1.线程池的掌握要加深

2.进程通信。

3.偏向锁、轻量级锁、重量级锁。

4.公平锁、非公平锁（各种锁 [https://www.cnblogs.com/qifengshi/p/6831055.html](https://www.cnblogs.com/qifengshi/p/6831055.html)）。

5.Linux排查内存占用等命令

二面：

1.网络编程

2.消息队列

3.贪心算法，01背包

三面：

进程通信，redis，场景。

---

招银网络：

数据库，MySQL数据类型，sql，索引，创建索引要注意的东西。

---

有赞：

时间段的那个题目

AOP实现原理，IOC的实现；

计算机组成原理，类加载。

---

百度：

代理、动态代理、正向代理、反向代理，

ThreadLocal

软引用，软连接……

LRU手撕

---

笔试：

1.设计文件夹用什么模式

2.最高内聚

3.DMA每传一个数据时间是一个__周期

4.小端，大端

---

微步在线面试   http状态码：

# 状态码系列。

1 系列主要用来：客户端和http服务器之间的沟通，如100continue

2 系列表示一般表示：成功的信息，200 ok

3 系列一般表示：客户端需要做些额外工作才能得到所需要的资源

4 系列：表示客户端这边出错 400 bad request ， 404 not found 有可能是掩盖 403 Forbidden 或401("Unauthorized")

5 系列 ：表示服务器端出错 500("Internal Server Error")

## 1XX：通知

1XX系列响应代码仅在与HTTP服务器沟通时使用。

* 100("Continue")

重要程度：中等，但（写操作时）很少用。

该响应代码表明：客户端应重新发送初始请求，并在请求中附上第一次请求时未提供的（可能很大或者包含敏感信息的）表示。客户端这次发送的请求不会被拒绝。

## 2XX: 成功

2XX系列响应代码表明操作成功了。

* 200("OK")

重要程度：非常高。

它表示服务器成功执行了客户端所请求的动作，并且在2XX系列里没有其他更适合的响应代码了。

实体主体：对于GET请求，服务器应返回客户端所请求资源的一个表示。对于其他请求，服务器应返回当前所选资源的一个表示，或者刚刚执行的动作的一个描述。

* 201("Created")

重要程度：高。

当服务器依照客户端的请求创建了一个新资源时，发送此响应代码。

响应报头：Location报头应包含指向新创建资源的规范URI。

实体主体：应该给出新创建资源的描述与链接。若已经在Location报头里给出了新资源的URI，那么可以用新资源的一个表示作为实体主体。

* 204("No Content")

重要程度：高。

若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。服务器也可以对GET请求返回此响应代码，这表明“客户端请求的资源存在，但其表示是空的”。注意与304("Not Modified")的区别。204常常用在Ajax应用里。服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素。

实体主体：不允许。

## 3XX 重定向

3XX系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。它们通常用于GET请求。他们通常告诉客户端需要向另一个URI发送GET请求，才能得到所需的表示。那个URI就包含在Location响应报头里。

* 303("See Other")

重要程度：高。

请求已经被处理，但服务器不是直接返回一个响应文档，而是返回一个响应文档的URI。该响应文档可能是一个静态的状态信息，也可能是一个更有趣的资源。对于后一种情况，303是一种令服务器可以“发送一个资源的表示，而不强迫客户端下载其所有数据”的方式。客户端可以向Location报头里的URI发送GET请求，但它不是必须这么做。

303响应代码是一种规范化资源URI的好办法。一个资源可以有多个URIs，但每个资源的规范URI只有一个，该资源的所有其他URIs都通过303指向该资源的规范URI，例如：303可以把一个对[http://www.example.com/software/current.tar.gz](http://www.example.com/software/current.tar.gz)的请求重定向到[http://www.example.com/software/1.0.2.tar.gz](http://www.example.com/software/1.0.2.tar.gz)。

响应报头：Location报头里包含资源的URI。

实体主体：一个包含指向新URI的链接的超文本文档。

* 304("Not Modified")

重要程度：高。

这个响应代码跟204("No Content")类似：响应实体主体都必须为空。但204用于没有主体数据的情况，而304用于有主体数据，但客户端已拥有该数据，没必要重复发送的情况。这个响应代码可用于条件HTTP请求（conditional HTTP request).如果客户端在发送GET请求时附上了一个值为Sunday的If-Modified-Since报头，而客户端所请求的表示在服务器端自星期日（Sunday）以来一直没有改变过，那么服务器可以返回一个304响应。服务器也可以返回一个200响应，但由于客户端已拥有该表示，因此重复发送该表示只会白白浪费宽带。

响应报头：需要提供Date报头。Etag与Content-Location报头的值，应该跟返回200响应时的一样。若Expires, Cache-Control及Vary报头的值自上次发送以来已经改变，那么就要提供这些报头。

实体主体：不允许。

* 307("Temporary Redirect")

重要程度：高。

请求还没有被处理，因为所请求的资源不在本地：它在另一个URI处。客户端应该向那个URI重新发送请求。就GET请求来说，它只是请求得到一个表示，该响应代码跟303没有区别。当服务器希望把客户端重新定向到一个镜像站点时，可以用307来响应GET请求。但对于POST，PUT及DELETE请求，它们希望服务器执行一些操作，307和303有显著区别。对POST，PUT或者DELETE请求响应303表明：操作已经成功执行，但响应实体将不随本响应一起返回，若客户端想要获取响应实体主体，它需要向另一个URI发送GET请求。而307表明：服务器尚未执行操作，客户端需要向Location报头里的那个URI重新提交整个请求。

响应报头： 把客户端应重新请求的那个URI放在Location报头里。

实体主体：一个包含指向新URI的链接的超文本文档。

## 4XX：客户端错误

这些响应代码表明客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正。

* 400("Bad Request")

重要程度：高。

这是一个通用的客户端错误状态，当其他4XX响应代码不适用时，就采用400。此响应代码通常用于“服务器收到客户端通过PUT或者POST请求提交的表示，表示的格式正确，但服务器不懂它什么意思”的情况。

实体主体：可以包含一个错误的描述文档。

* 401("Unauthorized")

重要程度：高。

客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。客户端提供了错误的证书，或者根本没有提供证书。这里的证书（credential）可以是一个用户名/密码，也可以市一个API key，或者一个认证令牌。客户端常常通过向一个URI发送请求，并查看收到401响应，以获知应该发送哪种证书，以及证书的格式。如果服务器不想让未授权的用户获知某个资源的存在，那么它可以谎报一个404而不是401。这样做的缺点是：客户端需要事先知道服务器接受哪种认证--这将导致HTTP摘要认证无法工作。

响应报头：WWW-Authenticate报头描述服务器将接受哪种认证。

实体主体：一个错误的描述文档。假如最终用户可通过“在网站上注册”的方式得到证书，那么应提供一个指向该注册页面的链接。

* 403("Forbidden")

重要程度：中等。

客户端请求的结构正确，但是服务器不想处理它。这跟证书不正确的情况不同--若证书不正确，应该发送响应代码401。该响应代码常用于一个资源只允许在特定时间段内访问，

或者允许特定IP地址的用户访问的情况。403暗示了所请求的资源确实存在。跟401一样，若服务器不想透露此信息，它可以谎报一个404。既然客户端请求的结构正确，那为什么还要把本响应代码放在4XX系列（客户端错误），而不是5XX系列（服务端错误）呢？因为服务器不是根据请求的结构，而是根据请求的其他方面（比如说发出请求的时间）作出的决定的。

实体主体：一个描述拒绝原因的文档（可选）。

* 404("Not Found")

重要程度：高。

这也许是最广为人知的HTTP响应代码了。404表明服务器无法把客户端请求的URI转换为一个资源。相比之下，410更有用一些。web服务可以通过404响应告诉客户端所请求的URI是空的，然后客户端就可以通过向该URI发送PUT请求来创建一个新资源了。但是404也有可能是用来掩饰403或者401.

* 409("Conflict")

重要程度：高。

此响应代码表明：你请求的操作会导致服务器的资源处于一种不可能或不一致的状态。例如你试图修改某个用户的用户名，而修改后的用户名与其他存在的用户名冲突了。

响应报头：若冲突是因为某个其他资源的存在而引起的，那么应该在Location报头里给出那个资源的URI。

实体主体：一个描述冲突的文档，以便客户端可以解决冲突。

## 5XX 服务端错误

这些响应代码表明服务器端出现错误。一般来说，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。有时，服务器能够估计客户端应在多久之后重试。并把该信息放在Retry-After响应报头里。

5XX系列响应代码在数量上不如4XX系列多，这不是因为服务器错误的几率小，而是因为没有必要如此详细--对于服务器方面的问题，客户端是无能为力的。

* 500("Internal Server Error")

重要程度：高。

这是一个通用的服务器错误响应。对于大多数web框架，如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。

* 502("Bad Gateway")

重要程度：低。

只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。若代理根本无法访问上行服务器，响应代码将是504。

---

地铁搜索器：

Station类：站点名，tostring，重写equals（），重写hashCode（）；

Connection类；和SubwayLoader类配合使用，存储的是（A-B-line），A的邻接站点。

Subway类：在这个类内有几个方法，1.获得所有方法，2.获得所有连接。3获得网络，4.利用1-2-3获得最短路径上的所有连接，（用了广度优先搜索）返回。

SubwayLoader类：从文件读入地铁站点和线路信息。

SubwayPrinter类： 输出类

SubwayTester类： 测试类，调用。

吹点：对面向对象这个概念有了更深入的认识，

------------------------分析过程------------------------

一、先要又从需求分析中获得用例俩用例

1.用户输入起始和终点，获得路线规划

2.管理员提供地铁路线信息，系统读入。

二、从详细用例中分析出软件功能列表

1.表示站点和路线

2.路线如何载入

3.找出两站之间的最短路径

4.呈现出来

------------------------设计过程------------------------

三、将功能划分到不同的模块中，模块化设计

3大模块，loader模块、subway模块、printer模块。建立起用例-功能-模块间的对应关系：

四、详细设计：文本分析，提取出类和方法并改进。

=======================================================

对面向对象分析设计有个更深的体会，带有创造性的用代码解决实际问题，让我深有体会，真正感觉可以用代码解决很多问题。而不仅仅是写个排序，写个类。

具体的收获包括，对集合类的使用，用到了ArrayList，LinkedList，HahsMap，重写equals(),重写hashCode（），文件读入。深度优先搜索。Java Swing（Frame里是东西南北，pannel 里是gridbagLayout）

bootstrap 究竟是怎么适应屏幕的：[https://blog.csdn.net/m0_37631322/article/details/81943134](https://blog.csdn.net/m0_37631322/article/details/81943134)

[https://zhidao.baidu.com/question/136355080173369325.html](https://zhidao.baidu.com/question/136355080173369325.html)

package myutils; 两个经典的排序算法

import java.util.Arrays;

import java.util.Random;

/**

* @author TQR

* 2019年9月24日

*/

public class DoubleSort {

    public static void main(String[]args) {

        Random r = new Random();

        int N = 11;

        int [] num1 = new int [N];

        int [] num2 = new int [N];

        for(int i=0;i<N;i++) {

            num1[i] = r.nextInt(100);

            num2[i] = num1[i];

        }

        System.out.println("befor mergeSort:"+Arrays.toString(num1));

        int [] tem = new int[num1.length];

        mergeSort(num1,0,num1.length-1,tem);

        System.out.println("after mergeSort:"+Arrays.toString(num1));

        System.out.println("befor quickSort:"+Arrays.toString(num2));

        quickSort(num2,0,num2.length-1);

        System.out.println("after quickSort:"+Arrays.toString(num2));

    }

    public static void mergeSort(int[] num,int begin,int end,int[] tem) {

        //递归退出条件

        if(begin == end) return;

        //递归调用，拆分--过程

        int mid = (begin+end)/2;

        mergeSort(num,begin,mid,tem);

        mergeSort(num,mid+1,end,tem);

        //合并过程

        int LL = begin;

        int LR = mid;

        int RL = mid+1;

        int RR = end;

        int k = begin;

        while(LL<=LR && RL<=RR) {

            if(num[LL] <= num[RL])

                tem[k++] = num[LL++];

            else

                tem[k++] = num[RL++];

        }

        while(LL<=LR) {

            tem[k++] = num[LL++];

        }

        while(RL<=RR) {

            tem[k++] = num[RL++];

        }

        for(int i=begin;i<=end;i++) {

            num[i] = tem[i];

        }

    }

    public static void quickSort(int[] num,int low,int high) {

        //递归退出条件

        if(low >= high) return ;

        //本次递归要做的事情

        int lowtem = low;

        int hightem = high;

        int base = num[low];

        while(low<high) {

            while(high>low && num[high]>=base) {

                high--;

            }

            num[low] = num[high];

            while(low<high && num[low]<=base) {

                low++;

            }

            num[high] = num[low];

        }//退出时 high==low;

        num[high] = base;

        //递归调用

        quickSort(num,lowtem,high-1);

        quickSort(num,high+1,hightem);

    }

}

去哪儿网一面：

Q1自我介绍，

Q2.网络了解吗，几种IO。

～我只是知道名字，NIO/AIO(此处说错了，我应该多说点，直接说不太了解)

Q3.用过那些技术？

～jsp，springmvc后台知道，但不是我写的。

Q4.进程通信了解吗？

～管道，共享内存，消息队列

Q4.详细说一下，应用场景……

～没有实际应用过。

那行，可以走了，有消息我们在通知你。

再见(ー_ー)!!
