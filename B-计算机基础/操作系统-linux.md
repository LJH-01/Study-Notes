# 操作系统-linux

[https://man.linuxde.net/](https://man.linuxde.net/)专门查询Linux命令的网站

[https://www.cnblogs.com/fnlingnzb-learner/p/5831284.html](https://www.cnblogs.com/fnlingnzb-learner/p/5831284.html)//常用命令大全

[https://blog.csdn.net/vblittleboy/article/details/8103264](https://blog.csdn.net/vblittleboy/article/details/8103264)//chomd 777

系统信息 

arch  显示机器的处理器架构(1) 

date  显示系统日期 

关机 (系统的关机、重启以及登出 ) 

shutdown -h now 关闭系统(1) 

shutdown -r now 重启(1) 

reboot 重启(2) 

logout 注销 

文件和目录 

cd /home 进入 '/ home' 目录' 

cd .. 返回上一级目录 

pwd 显示工作路径 

ls 查看目录中的文件 

tree 显示文件和目录由根目录开始的树形结构(1) 

lstree 显示文件和目录由根目录开始的树形结构(2) 

mkdir dir1 创建一个叫做 'dir1' 的目录' 

rm -f file1 删除一个叫做 'file1' 的文件' 

rmdir dir1 删除一个叫做 'dir1' 的目录' 

mv dir1 new_dir 重命名/移动 一个目录 

cp file1 file2 复制一个文件 

文件搜索 

find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 

whereis halt 显示一个二进制文件、源码或man的位置 

挂载一个文件系统 （mount/umount）

mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在 

umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/ mnt/hda2' 退出 

磁盘空间 (df/du)

df -h 显示已经挂载的分区列表 

du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间' 

du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 

用户和群组 (group/user)

groupadd group_name 创建一个新用户组 

groupdel group_name 删除一个用户组 

useradd user1 创建一个新用户 

userdel -r user1 删除一个用户 ( '-r' 排除主目录) 

passwd 修改口令 

文件的权限 - 使用 "+" 设置权限，使用 "-" 用于取消 ----------chmod

ls -lh 显示权限 

ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 

chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 

chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 

chmod 7 含义：rwx分别对应读写执行，4，2，1--7就是全部权限

文件的特殊属性 - 使用 "+" 设置权限，使用 "-" 用于取消 -----------chattr

chattr +a file1 只允许以追加方式读写文件 

chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 

lsattr 显示特殊的属性 

打包和压缩文件 ---------bizp2,bunzip2/gzip,guzip/rar a ,rar x/ tar

tar只是一个打包工具，不负责压缩, 压缩是由gzip与bzip2来实现的。.bz2和.gz的区别在于前者比后者压缩率更高，后者比前者花费更少的时间。gzip的压缩速度是最快的

bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 

bzip2 file1 压缩一个叫做 'file1' 的文件 

gunzip file1.gz 解压一个叫做 'file1.gz'的文件 

gzip file1 压缩一个叫做 'file1'的文件 

gzip -9 file1 最大程度压缩 

tar -cvf archive.tar file1 创建一个非压缩的 tarball 

RPM 包 - （Fedora, Redhat及类似系统） (rpm-软件包管理器)

YUM 软件包升级器 - （Fedora, RedHat及类似系统） 

DEB 包 (Debian, Ubuntu 以及类似系统) 

APT 软件工具 (Debian, Ubuntu 以及类似系统) 

rpm -ivh package.rpm 安装一个rpm包 

yum install package_name 下载并安装一个rpm包 

dpkg -i package.deb 安装/更新一个 deb 包 

apt-get install package_name 安装/更新一个 deb 包 

文本处理 

cat主要三大功能：

1.一次显示整个文件。 cat filename

2.从键盘创建一个文件。 cat > filename  只能创建新文件,不能编辑已有文件.

3.将几个文件合并为一个文件： $cat file1 file2 > file

grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本

sed 是 stream editor 的缩写，中文称之为“流编辑器”。是一个面向行处理的工具，它以“行”为处理单位，针对每一行进行处理，处理后的结果会输出到标准输出（STDOUT）。它不会对读取的文件做任何贸然的修改，而是将内容都输出到标准输出中。

echo命令, 在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的,主要功能是在显示器上显示一段文字，一般起到一个提示的作用。

paste该命令主要用来将多个文件的内容合并，与cut命令完成的功能刚好相反。

paste file1 file2 合并两个文件或两栏的内容 

sort file1 file2 排序两个文件的内容 

comm命令可以用于两个文件之间的比较

comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容 

comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容 

comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 

备份 

dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份 

dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份 

网络 - （以太网和WIFI无线） 

ifconfig eth0 显示一个以太网卡的配置 

---

自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。

Linux线程

LINUX线程的实现就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。

进程和线程

（1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元

（2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。

（3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束

（4）线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的

（5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源

（6）线程有自己的私有属性PCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块TCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

---

内存碎片

内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；

外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。

---

进程同步——睡眠理发师----读者写者----哲学家进餐

---

产生死锁的必要条件

互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。

请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。

不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。

环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

解决死锁的方法

资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）

只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请求保持条件）

可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）

资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

---

## 进程通信方式

### 1. 信号

linux定义了几十种信号，是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。

### 2.管道

管道允许在进程之间按先进先出的方式传送数据，是进程间通信的一种常见方式。实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。

![img](/home/tqr/Study-Notes/B-计算机基础/image/364303-20160828225350723-1962168981.png)

具有以下特点：

1) 管道是**半双工的**，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；

2) 匿名管道只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；

3) 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

管道分为pipe（无名管道）和fifo（命名管道）两种，除了建立、打开、删除的方式不同外，这两种管道几乎是一样的。他们都是通过内核缓冲区实现数据传输。

- pipe用于相关进程之间的通信，例如父进程和子进程，它通过pipe()系统调用来创建并打开，当最后一个使用它的进程关闭对他的引用时，pipe将自动撤销。
- FIFO即命名管道，在磁盘上有对应的节点，但没有数据块——换言之，只是拥有一个名字和相应的访问权限，通过mknode()系统调用或者mkfifo()函数来建立的。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。



### 3.消息队列

消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。

可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。

### 4. 共享内存通信----效率高--引文直接读写内存不需要任何数据拷贝

共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取措施读出，从而实现了进程间的通信。-----不保证同步，需要自己实现同步。

 采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。

![img](/home/tqr/Study-Notes/B-计算机基础/image/364303-20160829133915152-273836485.png)

一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。