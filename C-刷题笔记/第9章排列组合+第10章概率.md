# 第9章 排列组合

1. 基础题 主要是高中数学水平的排列组合。C nm = n! /(m!(n-m)!)

2. 主要是 卡特兰数的应用.

### 卡特兰数

令h(0)=1,h(1)=1，卡特兰数满足递推式:**h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)h(0) (n>=2)。**也就是说，如果能把公式化成上面这种形式的数，就是卡特兰数。卡特兰数的第n项等于  **h(n)=C(2n,n)/(n+1)**。

### 应用

1. 进出栈问题

	>n个数，每一步可以进栈也可以出栈，进栈顺序一定，共有多少种出栈顺序。
	>
	>分析： 假设第k个数 是最后一个出栈的数。也就是说在第k个元素进栈时栈为空。那么，比k早进栈且早出栈的有k-1个数，一共有h(k-1)种方案。比k晚进栈且早出栈的有n-k个数，一共有h(n-k)种方案。所以一共有h(k-1)\*h(n-k)种方案。k取不同值意味着第k个元素最后出栈，因此产生的出栈序列是相互独立的，所以结果可以累加。k的取值范围为1至n，所以结果就为 总共h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0)。 (n>=2)又 h(0) = 1;   s(1) = 1,。因此h(n) 是一个卡特兰数

2. 括号匹配

	> 有n对括号，问合法的排列共有多少种。
	>
	> 分析：当出现不合法括号组合时，一定是出现了先出现 右括号）的情形。首先第一个括号一定是左括号，还知道总共有n个右括号，假设第一个左括号和第k个右括号匹配起来了，即这个括号对中包裹了k-1对括号，括号外面还有n-k对括号，他们都必须合法，即 a(k) = h(k-1)* h(n-1) ，k可以从1取到n，因此，总共的合法对数是 h(n)  =  h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0)。 (n>=2)又 sum(0) = 1;   sum(1) = 1,。因此s(n) 是一个卡特兰数

3. 5元 和10元

	> 一群人去排队买票，一张票5元，该死的售票员不事先准备零钱，买票的人，一半拿得5元，一半拿得10元，怎么排队。
	>
	> 分析：看成    ----》----》------》------》-----》，从左到右肯定是先出现10元，后出现5元的队列。假设第 k个拿五元的人的钱找给第一个人，那么在他们中间夹着的k-1对人，的排列方式是一个h(k-1)问题，在第k个拿5元的人右侧有(n-k)对人，是一个h(n-k)   所以 a(k) = h(k-1)*h(n-k) , 所以 h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0)。 (n>=2)又 sum(0) = 1;   sum(1) = 1,。因此sum(n) 是一个卡特兰数n个节点的二叉树问题

4. > 有n个节点，可以构造多少种不同的二叉树，这里指结构不同。（先假设节点无差别，即不考虑节点值）
	>
	> 分析：一棵树的节点分为 1-左树上的节点，2-右树上的节点，3-根节点，因为此时节点无差别，可以假设以第k个节点位根结点，前面的是左树节点，后面的是右树节点，…… 卡特兰数，当考虑节点的差别时，即假设n个节点都时无重复，那么对于每种树的形态，又有 n!中分布， 在乘以n!

5. 凸多边形的三角形划分

	> 

6. 12个人排成两排，从左到右递增，从前往后递增。多少种排法

	> 将12个人先按从低到高  1  2  3  4  5  6  7  8  9  10 11
	>
	> 在下面标0或1 表示第一排或第二排 
	>
	> 1  2  3  4  5  6  7  8  9  10 11  
	>
	> 0  0  0  0  0  1  1  1  1    1    1    即转变为求多少合法01序列。

这类问题有几个明显特征，1栈的出栈顺序，2，括号匹配一类必须先于另一类，3。二叉树结构。4凸多边形划分

### 其他例题

1. 错装信封练习题

	> 有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法?

```java
//递归写法
 public int countWays(int n) {
        //错排公式
        if(n==1)  return 0; 
        if(n==2)  return 1;
        return (n-1)*(countWays(n-1)+countWays(n-2)) ;
    }//复杂度可能太大，例如栈的深度可能不够

//非递归的写法---斐波那契
public int countWays(int n) {
        long  tem = 0;
        long pre = 0;
        long after = 1; 
        if(n==0) return 0;
        else if(n==1) return 0;
        else if(n==2) return 1;
        else{            
            for(int i=3;i<=n;i++){
                tem = (i-1)*(pre+after)%1000000007;
                pre = after;
                after = tem;
            }
        }
        return (int)tem;
    }
```

# 第10章 概率

* 概率问题常作为客观题 即选择题出现，一般不会太难，不涉及高等概率论。往往还是古典概型（组合数学）

* 概率的应用：
	* 利用随即来该改进排序（快速排序）
	* 随机数发生器，考题：根据一个随机数发生器构造另外一个随机数发生器