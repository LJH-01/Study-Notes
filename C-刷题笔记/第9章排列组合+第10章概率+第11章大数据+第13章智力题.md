# 第9章 排列组合

1. 基础题 主要是高中数学水平的排列组合。C nm = n! /(m!(n-m)!)

2. 主要是 卡特兰数的应用.

### 卡特兰数

令h(0)=1,h(1)=1，卡特兰数满足递推式:**h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)h(0) (n>=2)。**也就是说，如果能把公式化成上面这种形式的数，就是卡特兰数。卡特兰数的第n项等于  **h(n)=C(2n,n)/(n+1)**。

### 应用

1. 进出栈问题

	>n个数，每一步可以进栈也可以出栈，进栈顺序一定，共有多少种出栈顺序。
	>
	>分析： 假设第k个数 是最后一个出栈的数。也就是说在第k个元素进栈时栈为空。那么，比k早进栈且早出栈的有k-1个数，一共有h(k-1)种方案。比k晚进栈且早出栈的有n-k个数，一共有h(n-k)种方案。所以一共有h(k-1)\*h(n-k)种方案。k取不同值意味着第k个元素最后出栈，因此产生的出栈序列是相互独立的，所以结果可以累加。k的取值范围为1至n，所以结果就为 总共h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0)。 (n>=2)又 h(0) = 1;   s(1) = 1,。因此h(n) 是一个卡特兰数

2. 括号匹配

	> 有n对括号，问合法的排列共有多少种。
	>
	> 分析：当出现不合法括号组合时，一定是出现了先出现 右括号）的情形。首先第一个括号一定是左括号，还知道总共有n个右括号，假设第一个左括号和第k个右括号匹配起来了，即这个括号对中包裹了k-1对括号，括号外面还有n-k对括号，他们都必须合法，即 a(k) = h(k-1)* h(n-1) ，k可以从1取到n，因此，总共的合法对数是 h(n)  =  h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0)。 (n>=2)又 sum(0) = 1;   sum(1) = 1,。因此s(n) 是一个卡特兰数

3. 5元 和10元

	> 一群人去排队买票，一张票5元，该死的售票员不事先准备零钱，买票的人，一半拿得5元，一半拿得10元，怎么排队。
	>
	> 分析：看成    ----》----》------》------》-----》，从左到右肯定是先出现10元，后出现5元的队列。假设第 k个拿五元的人的钱找给第一个人，那么在他们中间夹着的k-1对人，的排列方式是一个h(k-1)问题，在第k个拿5元的人右侧有(n-k)对人，是一个h(n-k)   所以 a(k) = h(k-1)*h(n-k) , 所以 h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0)。 (n>=2)又 sum(0) = 1;   sum(1) = 1,。因此sum(n) 是一个卡特兰数n个节点的二叉树问题

4. > 有n个节点，可以构造多少种不同的二叉树，这里指结构不同。（先假设节点无差别，即不考虑节点值）
	>
	> 分析：一棵树的节点分为 1-左树上的节点，2-右树上的节点，3-根节点，因为此时节点无差别，可以假设以第k个节点位根结点，前面的是左树节点，后面的是右树节点，…… 卡特兰数，当考虑节点的差别时，即假设n个节点都时无重复，那么对于每种树的形态，又有 n!中分布， 在乘以n!

5. 凸多边形的三角形划分

	> 

6. 12个人排成两排，从左到右递增，从前往后递增。多少种排法

	> 将12个人先按从低到高  1  2  3  4  5  6  7  8  9  10 11
	>
	> 在下面标0或1 表示第一排或第二排 
	>
	> 1  2  3  4  5  6  7  8  9  10 11  
	>
	> 0  0  0  0  0  1  1  1  1    1    1    即转变为求多少合法01序列。

这类问题有几个明显特征，1栈的出栈顺序，2，括号匹配一类必须先于另一类，3。二叉树结构。4凸多边形划分

### 其他例题

1. 错装信封练习题

	> 有n个信封，包含n封信，现在把信拿出来，再装回去，要求每封信不能装回它原来的信封，问有多少种装法?
	
	```java
	//递归写法
	 public int countWays(int n) {
	        //错排公式
	        if(n==1)  return 0; 
	        if(n==2)  return 1;
	        return (n-1)*(countWays(n-1)+countWays(n-2)) ;
	    }//复杂度可能太大，例如栈的深度可能不够
	
	//非递归的写法---斐波那契
	public int countWays(int n) {
	        long  tem = 0;
	        long pre = 0;
	        long after = 1; 
	        if(n==0) return 0;
	        else if(n==1) return 0;
	        else if(n==2) return 1;
	        else{            
	            for(int i=3;i<=n;i++){
	                tem = (i-1)*(pre+after)%1000000007;
	                pre = after;
	                after = tem;
	            }
	        }
	        return (int)tem;
	    }
	```

# 第10章 概率

* 概率问题常作为客观题 即选择题出现，一般不会太难，不涉及高等概率论。往往还是古典概型（组合数学）

* 概率的应用：
	* 利用随即来该改进排序（快速排序）
	* 随机数发生器，考题：根据一个随机数发生器构造另外一个随机数发生器

# 第11章 大数据

Map-Reduce 和 Hadoop

哈希函数：又叫散列函数，输入域可以是非常大的范围，输出域是固定范围，性质：

1. 典型的哈希函数都拥有无限的输入值域
2. 输入值相同时，返回值一样
3. 输入值不同时，返回值可能一样，也可能不一样
4. 不同输入值得到的哈希值，整体均匀的分布在输入域上（该条性质评价汉溪函数的优劣）

介绍Map-Reduce

1. Map阶段 -- 把大任务分成子任务。
2. Reduce阶段 -- 子任务并发处理然后合并结果

难点在于工程上的细节：

* 备份的考虑，分布时存储的设计细节，以及容灾策略。
* 任务分配策略于人物进度跟踪的细节设计，节点状态的呈现。
* 多用户权限的控制。

举例：

用 Map-Rduce方法统计一篇文章中每个单词出现的个数。

1. 预处理，变成只包含单词的文本。
	* 去掉标点符号
	* 处理连字符 -  
	* 处理缩写
	* 处理大小写
2. map阶段，对每个单词生成词频为1的记录，如（dog,1) (pig, 1) 通过哈希函数得到每个单词的哈希值，并根据该值分成若干组任务。对每个子任务，每个子任务中包含若干种单词，但同一种单词不会分配进不同的子任务中。对子任务中同一种单词的词频进行合并。再合并。得到每种单词的词频统计。

海量处理题解题关键。

1. 分而治之，通过哈希函数将大任务分流到机器或分流成小文件
2. 常用hashMap 或bitmap

难点在于：通讯、时间和空间的估算。举例：

案例1：

> 对10亿个IPV4的ip第孩子进行排序，每个地址只会出现一次。 使用bitmap

> 对10亿人的年龄排序。桶排序。

> 有一个大文件，包含20亿个全是32位整数的大文件，在其中找出出现次数最多的数，内存限制只有2G。 首先统计次数想到的是 hashmap 然后会有内存溢出，分流，按照数值 将文件分流成多个小文件，假设分布很均匀最好，如果分布不均匀会造成某个文件太大，就递归在分流，直到内存可以处理，这样得到每个文件内最多的数，因为相同的数都分流进相同的文件了，所以可以得到出现次数最多的数，再综合。

> 32位无符号整数的范围是0～4294967295。现在由一个正好包含40亿个无符号整数的文件，所以在整个范围内必然有没有出现过的数，可以使用最多10M的内存，之用找到一个没出现过的数即可，该如找。
>
> 还是根据数值分流，然后找到一个没有满的文件，纳闷这中间肯定有一个没有出现过的数，然后拿出来这个文件再用bitmap 查哪个数没出现过。

> 某搜索公司一天的用户搜索词汇是海量的，假设有百亿的数据量，设计一种求出每天最热100词的可行办法。
>
> 分析，统计次数还是哈希表
>
> 先用哈希函数分流，分流到不同个的机器上，在每个机器上如果还是会出现内存不足就继续分流成小文件，然后用哈希表统计词频，再然后用堆排序来排序出最多的前100，小根堆（遍历哈希表，每次选取出现次数最少的抛弃，遍历完留下的就是top100）

案例6

> 工程师常使用服务器集群来设计和实现数据缓存，以下是常见的策略，1，无论是添加，查询还是删除数据，都先将数据的id通过哈希函数转换成一个哈希值key。2，如果目前机器有N台，则计算key%N的值，这个值就是该数据所属的机器编号，无论是添加删除还是查询操作，都只在这台机器上进行，清分析这种缓存策略可能带来的问题，并提出改进方案。
>
> 潜在问题： 如果增加或删除机器时，数据迁移的代价会很大。因为不得不堆所有的哈希值重新取模来分配机器。
>
> 解决这个问题使用一致性哈希算法。
>
> 数据id通过哈希值计算后的结果为0～2^32，然后把这个数据域首尾相连变成一个环，对于n台机器，有一个机器id，通过哈希函数也映射到这个环上，每次杜宇数据id的哈希值，顺时针寻找里的最近的机器id，这样删除和增加机器的时候只需要，改动相应弧上的数据。

# 第13章 智力题

1. 涂格子问题n*m个格子，两个涂色的格子不能相邻，问最多能涂多少个格子。

	> return ((n*m)+1)/2;

2. 赛马问题

	> 给定两个数组，分别代表自己的马和对手的马的能力值，如果自己的值大于对手的值则能获胜，否则败，问最多能赢几场？
	>
	> 分析： 最多的话将对面当成傻子，先将两个数组排序，拿着自己的数组每次都尽可能那最弱的马赢下比赛，赢一场是一场。直到将我方可以赢得场次计算完。

3. 跳格子问题

	> 棋盘时n个格子，每次移动 或1 或2 或3 谁最后移出去谁赢，两者都时最优策略，给出n计算自己能否赢
	>
	> if(n%4==0 ) 输 
	>
	> else 赢。

4. 跳格子2

	> 从 （1，1） 走到（m，n）可以右走，上走，右上斜走，A先走，最后走到赢，给m，n问能否赢
	>
	> if(n==1 && m==1) 赢
	>
	> else { if(m,n都是奇数)输，否则赢}

5. 数组清空练习题

	> 一个数组，里面的数字是任意的，可以重复，每次的操作可以对其中同一种数字清除任意个，小于等于总数，每次至少清理掉一个，问先手能不能赢。
	>
	> 答案是，统计每种数字出现的次数，这些次数全部异或，如果最后值为1，能赢，否则输 

	```java 
	public class Clear {
	    public int getWinner(int[] A, int n) {
	        int[] count = new int[n + 1];
	        int res = 0;
	        for (int i = 0; i < n; i++) {
	            count[A[i]]++;
	        }
	        for (int i = 1; i <= n; i++) {
	            res ^= count[i];
	        }
	        return res == 0 ? 0 : 1;
	    }
	}
	```

	